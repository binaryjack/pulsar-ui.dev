/**
 * Pulsar Framework - Comprehensive Feature Showcase
 * Demonstrates all core reactivity features with visual examples
 */

import {
  createSignal,
  createEffect,
  createMemo,
  createContext,
  useContext,
  ForRegistry,
  ShowRegistry,
  bootstrapApp,
} from '@pulsar-framework/pulsar.dev';

// ============================================================================
// TEST 1: BASIC SIGNALS
// ============================================================================

const SignalTest = () => {
  const [count, setCount] = createSignal(0);
  const [name, setName] = createSignal('Pulsar');
  const [isActive, setIsActive] = createSignal(false);

  return (
    <div class="test-section">
      <h3>âœ¨ 1. Signal Reactivity Test</h3>
      
      <div class="signal-display">
        <p>Count: <strong>{count()}</strong></p>
        <p>Name: <strong>{name()}</strong></p>
        <p>Status: <strong>{isActive() ? 'âœ… Active' : 'âŒ Inactive'}</strong></p>
      </div>
      
      <div class="controls">
        <button onClick={() => setCount(count() + 1)}>â• Increment</button>
        <button onClick={() => setCount(count() - 1)}>â– Decrement</button>
        <button onClick={() => setCount(0)}>ğŸ”„ Reset</button>
        
        <input
          type="text"
          value={name()}
          onInput={(e) => setName(e.target.value)}
          placeholder="Enter name"
        />
        
        <button onClick={() => setIsActive(!isActive())}>
          {isActive() ? 'ğŸ”´ Deactivate' : 'ğŸŸ¢ Activate'}
        </button>
      </div>
      
      <div class="test-status">
        âœ… Signals update UI immediately on change
      </div>
    </div>
  );
};

// ============================================================================
// TEST 2: EFFECTS
// ============================================================================

const EffectTest = () => {
  const [input, setInput] = createSignal('');
  const [effectLog, setEffectLog] = createSignal([]);
  const [effectCount, setEffectCount] = createSignal(0);

  createEffect(() => {
    const currentInput = input();
    if (currentInput) {
      const timestamp = new Date().toLocaleTimeString();
      const log = currentInput + ' - ' + timestamp;
      setEffectLog([...effectLog(), log]);
      setEffectCount(effectCount() + 1);
    }
  });

  return (
    <div class="test-section">
      <h3>âš¡ 2. Effect Reactivity Test</h3>
      
      <div class="input-section">
        <label>Type something (triggers effect):</label>
        <input
          type="text"
          value={input()}
          onInput={(e) => setInput(e.target.value)}
          placeholder="Type here..."
        />
      </div>
      
      <div class="effect-stats">
        <p>Effect triggered: <strong>{effectCount()}</strong> times</p>
      </div>
      
      <div class="effect-log">
        <h4>Effect Log:</h4>
        <div class="log-entries">
          <ShowRegistry when={effectLog().length > 0} fallback={<div class="log-placeholder">No effects triggered yet...</div>}>
            <ForRegistry each={effectLog()}>
              {(entry, index) => (
                <div class="log-entry" key={index()}>
                  {entry()}
                </div>
              )}
            </ForRegistry>
          </ShowRegistry>
        </div>
      </div>
      
      <button onClick={() => {
        setInput('');
        setEffectLog([]);
        setEffectCount(0);
      }}>
        ğŸ—‘ï¸ Clear Log
      </button>
      
      <div class="test-status">
        âœ… Effects run automatically when tracked signals change
      </div>
    </div>
  );
};

// ============================================================================
// TEST 3: MEMOS (Computed Values)
// ============================================================================

const MemoTest = () => {
  const [firstName, setFirstName] = createSignal('John');
  const [lastName, setLastName] = createSignal('Doe');
  const [items, setItems] = createSignal([10, 20, 30, 40, 50]);

  const fullName = createMemo(() => firstName() + ' ' + lastName());
  const initials = createMemo(() => firstName()[0] + lastName()[0]);
  const itemsSum = createMemo(() => items().reduce((sum, n) => sum + n, 0));
  const itemsAverage = createMemo(() => {
    const sum = itemsSum();
    return items().length > 0 ? (sum / items().length).toFixed(2) : 0;
  });

  return (
    <div class="test-section">
      <h3>ğŸ§® 3. Memo (Computed Values) Test</h3>
      
      <div class="input-section">
        <label>First Name:</label>
        <input
          type="text"
          value={firstName()}
          onInput={(e) => setFirstName(e.target.value)}
        />
        
        <label>Last Name:</label>
        <input
          type="text"
          value={lastName()}
          onInput={(e) => setLastName(e.target.value)}
        />
      </div>
      
      <div class="computed-results">
        <h4>Computed Values (Memos):</h4>
        <p>Full Name: <strong>{fullName()}</strong></p>
        <p>Initials: <strong>{initials()}</strong></p>
      </div>
      
      <div class="numbers-section">
        <h4>Numbers: {items().join(', ')}</h4>
        <p>Sum: <strong>{itemsSum()}</strong></p>
        <p>Average: <strong>{itemsAverage()}</strong></p>
        
        <button onClick={() => setItems([...items(), Math.floor(Math.random() * 100)])}>
          â• Add Random Number
        </button>
        <button onClick={() => setItems([])}>ğŸ—‘ï¸ Clear Numbers</button>
      </div>
      
      <div class="test-status">
        âœ… Memos cache computed values and only recompute when dependencies change
      </div>
    </div>
  );
};

// ============================================================================
// TEST 4: CONTEXT API
// ============================================================================

const ThemeContext = createContext();

const ThemedComponent = () => {
  const context = useContext(ThemeContext);
  
  if (!context) {
    return <div>Error: No theme context provided</div>;
  }

  const { theme, fontSize } = context;
  
  const backgroundColor = theme() === 'dark' ? '#1a202c' : '#ffffff';
  const textColor = theme() === 'dark' ? '#e2e8f0' : '#1a202c';

  return (
    <div
      class="themed-content"
      style={'background-color: ' + backgroundColor + '; color: ' + textColor + '; padding: 20px; border-radius: 8px; font-size: ' + fontSize() + 'px; transition: all 0.3s ease;'}
    >
      <p>This component uses context values:</p>
      <ul>
        <li>Theme: <strong>{theme()}</strong></li>
        <li>Font Size: <strong>{fontSize()}px</strong></li>
      </ul>
    </div>
  );
};

const ContextTest = () => {
  const [theme, setTheme] = createSignal('light');
  const [fontSize, setFontSize] = createSignal(16);

  const contextValue = {
    theme,
    setTheme,
    fontSize,
    setFontSize,
  };

  return (
    <div class="test-section">
      <h3>ğŸ¨ 4. Context API Test</h3>
      
      <div class="controls">
        <button onClick={() => setTheme(theme() === 'light' ? 'dark' : 'light')}>
          {theme() === 'light' ? 'ğŸŒ™ Dark Mode' : 'â˜€ï¸ Light Mode'}
        </button>
        
        <label>
          Font Size: {fontSize()}px
          <input
            type="range"
            min="12"
            max="32"
            value={fontSize()}
            onInput={(e) => setFontSize(parseInt(e.target.value))}
          />
        </label>
      </div>
      
      <ThemeContext.Provider value={contextValue}>
        <ThemedComponent />
      </ThemeContext.Provider>
      
      <div class="test-status">
        âœ… Context allows sharing state across component tree without props
      </div>
    </div>
  );
};

// ============================================================================
// TEST 5: CONTROL FLOW - Lists
// ============================================================================

const ListTest = () => {
  const [items, setItems] = createSignal(['Apple', 'Banana', 'Cherry']);
  const [newItem, setNewItem] = createSignal('');

  const addItem = () => {
    if (newItem().trim()) {
      setItems([...items(), newItem()]);
      setNewItem('');
    }
  };

  const removeItem = (index) => {
    setItems(items().filter((_, i) => i !== index));
  };

  return (
    <div class="test-section">
      <h3>ğŸ“ 5. List Rendering Test (ForRegistry)</h3>
      
      <div class="controls">
        <input
          type="text"
          value={newItem()}
          onInput={(e) => setNewItem(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && addItem()}
          placeholder="Enter item name"
        />
        <button onClick={addItem}>â• Add Item</button>
      </div>
      
      <div class="item-list">
        <ShowRegistry when={items().length > 0} fallback={<div class="empty-state">No items yet. Add some!</div>}>
          <ul>
            <ForRegistry each={items()}>
              {(item, index) => (
                <li key={index()}>
                  <span>{item()}</span>
                  <button onClick={() => removeItem(index())} class="remove-btn">
                    ğŸ—‘ï¸ Remove
                  </button>
                </li>
              )}
            </ForRegistry>
          </ul>
        </ShowRegistry>
      </div>
      
      <div class="test-status">
        âœ… ForRegistry efficiently renders dynamic lists with keyed items
      </div>
    </div>
  );
};

// ============================================================================
// TEST 6: CONDITIONAL RENDERING
// ============================================================================

const ConditionalTest = () => {
  const [mode, setMode] = createSignal('success');
  const modes = ['success', 'warning', 'error', 'info'];

  return (
    <div class="test-section">
      <h3>ğŸ”€ 6. Conditional Rendering Test (ShowRegistry)</h3>
      
      <div class="controls">
        {modes.map((m) => (
          <button 
            key={m}
            onClick={() => setMode(m)}
            class={mode() === m ? 'active' : ''}
          >
            {m.toUpperCase()}
          </button>
        ))}
      </div>
      
      <div class="conditional-display">
        <ShowRegistry when={mode() === 'success'}>
          <div class="alert alert-success">
            âœ… Success! Everything is working perfectly.
          </div>
        </ShowRegistry>
        
        <ShowRegistry when={mode() === 'warning'}>
          <div class="alert alert-warning">
            âš ï¸ Warning! Please check your inputs.
          </div>
        </ShowRegistry>
        
        <ShowRegistry when={mode() === 'error'}>
          <div class="alert alert-error">
            âŒ Error! Something went wrong.
          </div>
        </ShowRegistry>
        
        <ShowRegistry when={mode() === 'info'}>
          <div class="alert alert-info">
            â„¹ï¸ Info: This is an informational message.
          </div>
        </ShowRegistry>
      </div>
      
      <div class="test-status">
        âœ… ShowRegistry conditionally renders components reactively
      </div>
    </div>
  );
};

// ============================================================================
// MAIN APP
// ============================================================================

const ShowcaseApp = () => {
  return (
    <div class="showcase-container">
      <header class="showcase-header">
        <h1>âš¡ Pulsar Framework - Feature Showcase</h1>
        <p>Comprehensive demonstration of all core reactivity features</p>
      </header>
      
      <main class="showcase-main">
        <SignalTest />
        <EffectTest />
        <MemoTest />
        <ContextTest />
        <ListTest />
        <ConditionalTest />
      </main>
      
      <footer class="showcase-footer">
        <p>âœ¨ All features working! Pulsar Framework v0.7.0-alpha</p>
      </footer>
    </div>
  );
};

// Bootstrap and mount
bootstrapApp()
  .root('#app')
  .onMount((element) => {
    console.log('[Pulsar] Showcase mounted successfully', element);
  })
  .onError((error) => {
    console.error('[Pulsar] Error:', error);
  })
  .build()
  .mount(ShowcaseApp());

export default ShowcaseApp;
