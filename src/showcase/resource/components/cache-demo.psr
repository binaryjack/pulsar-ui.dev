/**
 * Cache Demo Component
 * Shows stale-while-revalidate caching
 */

import { createSignal, createResource, ShowRegistry, onCleanup, onMount } from '@pulsar-framework/pulsar.dev';
import { DemoButton } from '../../common/components/demo-button.psr';
import { fetchUser } from './mock-api.ts';

export const CacheDemo = () => {
  const [fetchCount, setFetchCount] = createSignal(0);
  const [cacheHits, setCacheHits] = createSignal(0);
  const [lastFetchTime, setLastFetchTime] = createSignal(0);
  const [isRefetching, setIsRefetching] = createSignal(false);
  const [isFresh, setIsFresh] = createSignal(true);
  
  // Debounce token management (plain vars - no reactivity needed)
  let debounceTimeout: NodeJS.Timeout | null = null;
  let timerInterval: NodeJS.Timeout | null = null;
  
  const cachedResource = createResource(() => {
    setFetchCount(c => c + 1);
    setLastFetchTime(Date.now());
    return fetchUser(1);
  }, { staleTime: 5000 });
  
  // After mount: start interval with direct DOM reads/writes
  // Using getElementById avoids ref callbacks (not supported by transformer)
  // Reading signal inside setInterval is NOT tracked (no reactive context) -> no wire
  onMount(() => {
    timerInterval = setInterval(() => {
      const fetchTime = lastFetchTime(); // plain read, not tracked
      if (fetchTime === 0) return;
      
      const elapsed = Date.now() - fetchTime;
      const timeLeft = Math.max(0, 5000 - elapsed);
      const fresh = timeLeft > 0;
      const timeLeftSeconds = (timeLeft / 1000).toFixed(1);
      const progressPct = Math.max(0, Math.min(100, (timeLeft / 5000) * 100));
      
      // Direct DOM manipulation - completely outside reactive system
      const statusEl = document.getElementById('cache-status-text') as HTMLElement | null;
      const progressEl = document.getElementById('cache-progress-bar') as HTMLElement | null;
      
      if (statusEl) {
        statusEl.style.color = fresh ? '#10b981' : '#ef4444';
        statusEl.textContent = fresh ? `Fresh (${timeLeftSeconds}s left)` : 'Stale';
      }
      
      if (progressEl) {
        progressEl.style.background = fresh ? '#10b981' : '#ef4444';
        progressEl.style.width = `${progressPct}%`;
      }
      
      // Only update signal when crossing fresh/stale threshold (2 updates max per fetch)
      if (fresh !== isFresh()) {
        setIsFresh(fresh);
      }
    }, 100);
  });
  
  // Cleanup timer and debounce on unmount
  onCleanup(() => {
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
    if (debounceTimeout) {
      clearTimeout(debounceTimeout);
      debounceTimeout = null;
    }
  });
  
  // Debounced refetch with cancellation token
  const refetchWithCheck = () => {
    if (debounceTimeout) {
      clearTimeout(debounceTimeout);
      debounceTimeout = null;
    }
    
    if (isRefetching()) return;
    
    debounceTimeout = setTimeout(async () => {
      setIsRefetching(true);
      const elapsed = Date.now() - lastFetchTime();
      if (cachedResource.data && elapsed < 5000) {
        setCacheHits(h => h + 1);
      }
      await cachedResource.refetch();
      setIsRefetching(false);
      debounceTimeout = null;
    }, 150);
  };
  
  return (
    <div>
      <DemoButton 
        onClick={refetchWithCheck} 
        color="#8b5cf6" 
        style="margin-bottom: 15px;"
        disabled={isRefetching()}
      >
        {isRefetching() ? '‚è≥ Refetching...' : 'üîÑ Refetch Data'}
      </DemoButton>
      
      <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 15px;">
        <div style="padding: 15px; background: #1a1a1a; border-radius: 4px; text-align: center;">
          <div style="font-size: 32px; color: #ef4444; font-weight: bold;">{fetchCount()}</div>
          <div style="color: #94a3b8; font-size: 12px;">Network Requests</div>
        </div>
        
        <div style="padding: 15px; background: #1a1a1a; border-radius: 4px; text-align: center;">
          <div style="font-size: 32px; color: #10b981; font-weight: bold;">{cacheHits()}</div>
          <div style="color: #94a3b8; font-size: 12px;">Cache Hits</div>
        </div>
      </div>
      
      <ShowRegistry when={() => cachedResource.data}>
        <div style="padding: 15px; background: #1a1a1a; border-radius: 4px; border-left: 3px solid #8b5cf6;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <div style="color: #8b5cf6; font-weight: bold;">üì¶ Cached Data</div>
            <div 
              id="cache-status-text"
              style="font-size: 12px; font-weight: bold; color: #94a3b8;"
            >
              Waiting for data...
            </div>
          </div>
          
          <div style="width: 100%; height: 6px; background: #334155; border-radius: 3px; margin-bottom: 15px; overflow: hidden;">
            <div 
              id="cache-progress-bar"
              style="height: 100%; background: #10b981; width: 0%; transition: width 0.1s linear;"
            ></div>
          </div>
          
          <div style="display: flex; gap: 15px; align-items: center;">
            <img 
              src={cachedResource.data?.avatar} 
              alt={cachedResource.data?.name}
              style="width: 50px; height: 50px; border-radius: 50%;"
            />
            <div>
              <div style="color: white; font-weight: bold;">{cachedResource.data?.name}</div>
              <div style="color: #94a3b8; font-size: 12px;">{cachedResource.data?.email}</div>
            </div>
          </div>
          <div style="color: #64748b; font-size: 11px; margin-top: 10px;">
            üí° Refetch while fresh = instant cache hit. After 5s = stale-while-revalidate.
          </div>
        </div>
      </ShowRegistry>
    </div>
  );
};
