/**
 * Cache Demo Component
 * Shows stale-while-revalidate caching
 */

import { createSignal, createResource, ShowRegistry, onCleanup, createEffect } from '@pulsar-framework/pulsar.dev';
import { DemoButton } from '../../common/components/demo-button.psr';
import { fetchUser } from './mock-api.ts';

export const CacheDemo = () => {
  const [fetchCount, setFetchCount] = createSignal(0);
  const [cacheHits, setCacheHits] = createSignal(0);
  const [lastFetchTime, setLastFetchTime] = createSignal(0);
  const [isRefetching, setIsRefetching] = createSignal(false);
  const [isFresh, setIsFresh] = createSignal(true);
  
  // Refs for direct DOM manipulation (avoid reactive loops)
  let statusTextRef: HTMLDivElement | null = null;
  let progressBarRef: HTMLDivElement | null = null;
  
  // Debounce token management
  let debounceTimeout: NodeJS.Timeout | null = null;
  let animationFrameId: number | null = null;
  
  const cachedResource = createResource(() => {
    setFetchCount(c => c + 1);
    setLastFetchTime(Date.now());
    return fetchUser(1);
  }, { staleTime: 5000 });
  
  // Update timer with direct DOM manipulation (no reactive signals)
  const updateTimer = (fetchTime: number) => {
    const update = () => {
      const elapsed = Date.now() - fetchTime;
      const timeLeft = Math.max(0, 5000 - elapsed);
      const timeLeftSeconds = (timeLeft / 1000).toFixed(1);
      const progressPct = Math.max(0, Math.min(100, (timeLeft / 5000) * 100));
      const fresh = timeLeft > 0;
      
      // Direct DOM updates (bypass reactive system)
      if (statusTextRef) {
        const color = fresh ? '#10b981' : '#ef4444';
        const text = fresh ? `Fresh (${timeLeftSeconds}s left)` : 'Stale';
        statusTextRef.style.color = color;
        statusTextRef.textContent = text;
      }
      
      if (progressBarRef) {
        const bgColor = fresh ? '#10b981' : '#ef4444';
        progressBarRef.style.background = bgColor;
        progressBarRef.style.width = `${progressPct}%`;
      }
      
      // Update signal state only when crossing threshold (reduce reactive updates)
      if (fresh !== isFresh()) {
        setIsFresh(fresh);
      }
      
      // Continue animation loop
      if (timeLeft > 0 || elapsed < 6000) {
        animationFrameId = requestAnimationFrame(() => update());
      }
    };
    
    update();
  };
  
  // React to fetch time changes
  createEffect(() => {
    const fetchTime = lastFetchTime();
    
    // Cancel previous animation loop
    if (animationFrameId !== null) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }
    
    // Start new animation loop if we have a fetch time
    if (fetchTime > 0) {
      updateTimer(fetchTime);
    }
    
    // Cleanup on re-run
    return () => {
      if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    };
  });
  
  // Component cleanup
  onCleanup(() => {
    if (animationFrameId !== null) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }
    if (debounceTimeout) {
      clearTimeout(debounceTimeout);
      debounceTimeout = null;
    }
  });
  
  // Debounced refetch with cancellation token
  const refetchWithCheck = () => {
    // Cancel any pending debounced call
    if (debounceTimeout) {
      clearTimeout(debounceTimeout);
      debounceTimeout = null;
    }
    
    // Ignore if already refetching
    if (isRefetching()) {
      return;
    }
    
    // Debounce: schedule refetch after 150ms
    debounceTimeout = setTimeout(async () => {
      setIsRefetching(true);
      
      const now = Date.now();
      const elapsed = now - lastFetchTime();
      
      if (cachedResource.data && elapsed < 5000) {
        setCacheHits(h => h + 1);
      }
      
      await cachedResource.refetch();
      
      setIsRefetching(false);
      debounceTimeout = null;
    }, 150);
  };
  
  return (
    <div>
      <DemoButton 
        onClick={refetchWithCheck} 
        color="#8b5cf6" 
        style="margin-bottom: 15px;"
        disabled={isRefetching()}
      >
        {isRefetching() ? '‚è≥ Refetching...' : 'üîÑ Refetch Data'}
      </DemoButton>
      
      <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 15px;">
        <div style="padding: 15px; background: #1a1a1a; border-radius: 4px; text-align: center;">
          <div style="font-size: 32px; color: #ef4444; font-weight: bold;">{fetchCount()}</div>
          <div style="color: #94a3b8; font-size: 12px;">Network Requests</div>
        </div>
        
        <div style="padding: 15px; background: #1a1a1a; border-radius: 4px; text-align: center;">
          <div style="font-size: 32px; color: #10b981; font-weight: bold;">{cacheHits()}</div>
          <div style="color: #94a3b8; font-size: 12px;">Cache Hits</div>
        </div>
      </div>
      
      <ShowRegistry when={() => cachedResource.data}>
        <div style="padding: 15px; background: #1a1a1a; border-radius: 4px; border-left: 3px solid #8b5cf6;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <div style="color: #8b5cf6; font-weight: bold;">üì¶ Cached Data</div>
            <div 
              ref={(el) => { statusTextRef = el; }}
              style="font-size: 12px; font-weight: bold; color: #10b981;"
            >
              Fresh (5.0s left)
            </div>
          </div>
          
          <div style="width: 100%; height: 6px; background: #334155; border-radius: 3px; margin-bottom: 15px; overflow: hidden;">
            <div 
              ref={(el) => { progressBarRef = el; }}
              style="height: 100%; background: #10b981; width: 100%; transition: width 0.1s linear;"
            ></div>
          </div>
          
          <div style="display: flex; gap: 15px; align-items: center;">
            <img 
              src={cachedResource.data?.avatar} 
              alt={cachedResource.data?.name}
              style="width: 50px; height: 50px; border-radius: 50%;"
            />
            <div>
              <div style="color: white; font-weight: bold;">{cachedResource.data?.name}</div>
              <div style="color: #94a3b8; font-size: 12px;">{cachedResource.data?.email}</div>
            </div>
          </div>
          <div style="color: #64748b; font-size: 11px; margin-top: 10px;">
            üí° Refetch while fresh = instant cache hit. After 5s = stale-while-revalidate.
          </div>
        </div>
      </ShowRegistry>
    </div>
  );
};
